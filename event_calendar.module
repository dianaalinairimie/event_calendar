<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\node\NodeInterface;

/**
 * Implements hook_install().
 */
function event_calendar_install() {
  // Defines default events status.
  $new_terms = array('Approved', 'Denied', 'Pending');

  // Create terms of events status vocabulary.
  if (!empty(Vocabulary::load('events_status'))) {
    foreach ($new_terms as $new_term) {
      $term = Term::create([
        'vid' => 'events_status',
        'name' => $new_term,
      ]);
      $term->save();
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function event_calendar_node_presave(EntityInterface $node) {
  // Alter node if is event and if is new.
  if ($node->bundle() == 'event_calendar' && $node->isNew()) {
    $terms = \Drupal::entityTypeManager()
      ->getStorage('taxonomy_term')
      ->loadByProperties(['name' => setDefaultStatus()]);
    foreach ($terms as $term) {
      if ($term->get('vid')
          ->first()
          ->getValue()['target_id'] == 'events_status'
      ) {
        // Sets default status of event on "Pending" or "Approved".
        $node->set('field_event_status', $term->id());
      }
    }

    // Send email when a new event is created if this setting exists.
    // @todo: send email to administrator when new event is added.
  }
}

/**
 * Returns the status of the event chosen on configurations.
 *
 * @return string
 *   The name of the status.
 */
function setDefaultStatus() {
  if (\Drupal::config('events.settings')->get('status')) {
    return 'Approved';
  }
  else {
    return 'Pending';
  }
}

/**
 * Implements hook_uninstall().
 */
function event_calendar_uninstall() {
  $storage_handler = \Drupal::entityTypeManager()->getStorage("node");
  $entities = $storage_handler->loadByProperties(["type" => "event_calendar"]);
  $storage_handler->delete($entities);
}

/**
 * Implements hook_views_data_alter().
 */
function event_calendar_views_data_alter(array &$event) {
  $event['node']['event_calendar_bulk_form'] = array(
    'title' => t('Event operations bulk form'),
    'help' => t('Add a form element that lets you run operations on multiple events.'),
    'field' => array(
      'id' => 'event_calendar_bulk_form',
    ),
  );

}

/**
 * Helper function to send emails on event update.
 *
 * @param $event_entity
 *   The updated event calendar entity.
 */
function updateEvents($event_entity) {
  // Events settings.
  $events_settings = \Drupal::config('events.settings');

  // The recipients options.
  $recipients_options = $events_settings->get('recipients_approved_events');
  // Sends emails only to users who have the configured role.
  foreach ($recipients_options as $recipient) {
    if(!empty($recipient)) {
      $email_subject = $events_settings->get('users_email_subject');
      $email_content = $events_settings->get('users_email_content');

      // @todo: send emails to specified users.
    }
  }
}

/**
 * Implements hook_node_update().
 */
function event_calendar_node_update(NodeInterface $node) {
  // Dispatch content validated event.
  if ($node->bundle() == 'event_calendar' && $node->hasField('field_event_status') && !empty($node->get('field_event_status')->value) && empty($node->original->get('field_event_status')->value)) {
    // Send email after event was approved or denied.
    updateEvents($node);
  }
}
