<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\Core\Url;
use Drupal\Core\Database\Database;

/**
 * Implements hook_install().
 */
function event_calendar_install() {
  // Defines default events status.
  $new_terms = array('Approved', 'Denied', 'Pending');

  // Create terms of events status vocabulary.
  if (!empty(Vocabulary::load('events_status'))) {
    foreach ($new_terms as $new_term) {
      $term = Term::create([
        'vid' => 'events_status',
        'name' => $new_term,
      ]);
      $term->save();
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function event_calendar_node_presave(EntityInterface $node) {
  // Alter node if is event and if is new.
  if ($node->bundle() == 'event_calendar' && $node->isNew()) {
    $terms = \Drupal::entityTypeManager()
      ->getStorage('taxonomy_term')
      ->loadByProperties(['name' => setDefaultStatus()]);
    foreach ($terms as $term) {
      if ($term->get('vid')
          ->first()
          ->getValue()['target_id'] == 'events_status'
      ) {
        // Sets default status of event on "Pending" or "Approved".
        $node->set('field_event_status', $term->id());
      }
    }

    // Events settings.
    $events_settings = \Drupal::config('events.settings');

    if (!empty($event_status = $node->get('field_event_status')
      ->first())
    ) {
      $status_name = \Drupal::service('entity_type.manager')
        ->getStorage('taxonomy_term')
        ->load($event_status->getValue()['target_id']);
    }

    // The recipient options.
    $data = [
      'event_name' => $node->getTitle(),
      'site_name' => \Drupal::config('system.site')->get('name'),
      'start_date' => $node->get('field_event_date')
        ->first()
        ->getValue()['value'],
      'event_author' => $node->getOwner()->getDisplayName(),
      'approval_url' => \Drupal::request()
          ->getSchemeAndHttpHost() . Url::fromRoute('event_calendar.manage_events')
          ->toString(),
      'event_status' => $status_name->getName()
    ];

    $params = [
      'subject' => Drupal::service('token')
        ->replace($events_settings->get('admin_email_subject'), $data),
      'body' => Drupal::service('token')
        ->replace($events_settings->get('admin_email_content'), $data)
    ];

    // Send email when a new event is created if this setting exists.
    send_email('event_calendar', 'basic', \Drupal::currentUser()
      ->getEmail(), \Drupal::currentUser()
      ->getPreferredLangcode(), $params);
  }
}

/**
 * 
 * @param $module
 * @param $key
 * @param $to
 * @param $langcode
 * @param $params
 */
function send_email($module, $key, $to, $langcode, $params) {
  \Drupal::service('plugin.manager.mail')
    ->mail($module, $key, $to, $langcode, $params);
}

/**
 * Returns the status of the event chosen on configurations.
 *
 * @return string
 *   The name of the status.
 */
function setDefaultStatus() {
  if (\Drupal::config('events.settings')->get('status')) {
    return 'Approved';
  }
  else {
    return 'Pending';
  }
}

/**
 * Implements hook_views_data_alter().
 */
function event_calendar_views_data_alter(array &$event) {
  $event['node']['event_calendar_bulk_form'] = array(
    'title' => t('Event operations bulk form'),
    'help' => t('Add a form element that lets you run operations on multiple events.'),
    'field' => array(
      'id' => 'event_calendar_bulk_form',
    ),
  );

}

/**
 * Implements hook_form_alter().
 */
function event_calendar_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Don't allow module uninstall if content of type 'event_calendar' exists.
  if ($form_id == 'system_modules_uninstall_confirm_form') {
    $storage_handler = \Drupal::entityTypeManager()->getStorage("node");
    $entities = $storage_handler->loadByProperties(["type" => "event_calendar"]);
    if (!empty($entities)) {
      $form_state->setError($form, 'Existing content');
      drupal_set_message('You can not remove this module until you have removed all of the Event calendar content.', 'error');
    }
  }
}

/**
 * Helper function to send emails on event update.
 *
 * @param $event_entity
 *   The updated event calendar entity.
 */
function updateEvents($event_entity) {
  // Events settings.
  $events_settings = \Drupal::config('events.settings');

  // The recipients options.
  $recipients_options = $events_settings->get('recipients_approved_events');
  // Sends emails only to users who have the configured role.

  if (!empty($recipients_options)) {
    if (!empty($event_status = $event_entity->get('field_event_status')
      ->first())
    ) {
      $status_name = \Drupal::service('entity_type.manager')
        ->getStorage('taxonomy_term')
        ->load($event_status->getValue()['target_id']);
    }

    $data = [
      'event_name' => $event_entity->getTitle(),
      'site_name' => \Drupal::config('system.site')->get('name'),
      'start_date' => $event_entity->get('field_event_date')
        ->first()
        ->getValue()['value'],
      'event_author' => $event_entity->getOwner()->getDisplayName(),
      'approval_url' => \Drupal::request()
          ->getSchemeAndHttpHost() . Url::fromRoute('event_calendar.manage_events')
          ->toString(),
      'event_status' => $status_name->getName()
    ];

    // The recipient options.
    $params = [
      'subject' => Drupal::service('token')
        ->replace($events_settings->get('users_email_subject'), $data),
      'body' => Drupal::service('token')
        ->replace($events_settings->get('users_email_content'), $data)
    ];

    /** @var QueueFactory $queue_factory */
    $queue_factory = \Drupal::service('queue');
    /** @var QueueInterface $queue */
    $queue = $queue_factory->get('email_processor');

    foreach ($recipients_options as $role) {
      if (!empty($role)) {
        $ids = Database::getConnection('default')
          ->select('user__roles', 'ur')
          ->fields('ur', ['entity_id'])
          ->condition('ur.roles_target_id', $role)
          ->execute()
          ->fetchAll();
        foreach ($ids as $id) {
          $user = \Drupal::service('entity_type.manager')
            ->getStorage('user')
            ->load($id->entity_id);
          $item = new \stdClass();
          $item->id = $id->entity_id;
          $item->data = $params;
          $item->email = $user->getEmail();
          $item->langcode = $user->getPreferredLangcode();
          $queue->createItem($item);
        }
      }
    }
  }

}

/**
 * Implements hook_node_update().
 */
function event_calendar_node_update(NodeInterface $node) {
  // Dispatch content validated event.
  if ($node->bundle() == 'event_calendar' && $node->hasField('field_event_status') && !empty($node->get('field_event_status')
      ->first()) && !empty($node->original->get('field_event_status')->first())
  ) {
    // Send email after event was approved or denied.
    updateEvents($node);
  }
}

/**
 * Implements hook_mail().
 */
function event_calendar_mail($key, &$message, $params) {
  switch ($key) {
    case 'basic':
      $message['from'] = \Drupal::config('system.site')->get('mail');
      $message['headers']['Content-Type'] = 'text/html';
      $message['subject'] = $params['subject'];
      $message['body'][0] = render($params['body']);
      break;
  }
}
